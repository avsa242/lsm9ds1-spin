'*********************************************
'* Spin code generated by cspin version 0.82 *
'*********************************************

{*
 * @file libLSM9DS1.c
 *
 * @author Matthew Matz
 *
 * @version 0.5
 *
 * @copyright
 * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
 *
 * @brief Test harness for the Propeller C library for the Parallax 9-axis IMU Sensor, based
 * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
 }
CON

  _clkmode = xtal1 + pll16x
  _xinfreq = 5_000_000

CON
  ACT_THS = $04
  ACT_DUR = $05
  INT_GEN_CFG_XL = $06
  INT_GEN_THS_X_XL = $07
  INT_GEN_THS_Y_XL = $08
  INT_GEN_THS_Z_XL = $09
  INT_GEN_DUR_XL = $0A
  REFERENCE_G = $0B
  INT1_CTRL = $0C
  INT2_CTRL = $0D
  WHO_AM_I_XG = $0F
  CTRL_REG1_G = $10
  CTRL_REG2_G = $11
  CTRL_REG3_G = $12
  ORIENT_CFG_G = $13
  INT_GEN_SRC_G = $14
  OUT_TEMP_L = $15
  OUT_TEMP_H = $16
  STATUS_REG_0 = $17
  OUT_X_L_G = $18
  OUT_X_H_G = $19
  OUT_Y_L_G = $1A
  OUT_Y_H_G = $1B
  OUT_Z_L_G = $1C
  OUT_Z_H_G = $1D
  CTRL_REG4 = $1E
  CTRL_REG5_XL = $1F
  CTRL_REG6_XL = $20
  CTRL_REG7_XL = $21
  CTRL_REG8 = $22
  CTRL_REG9 = $23
  CTRL_REG10 = $24
  INT_GEN_SRC_XL = $26
  STATUS_REG_1 = $27
  OUT_X_L_XL = $28
  OUT_X_H_XL = $29
  OUT_Y_L_XL = $2A
  OUT_Y_H_XL = $2B
  OUT_Z_L_XL = $2C
  OUT_Z_H_XL = $2D
  FIFO_CTRL = $2E
  FIFO_SRC = $2F
  INT_GEN_CFG_G = $30
  INT_GEN_THS_XH_G = $31
  INT_GEN_THS_XL_G = $32
  INT_GEN_THS_YH_G = $33
  INT_GEN_THS_YL_G = $34
  INT_GEN_THS_ZH_G = $35
  INT_GEN_THS_ZL_G = $36
  INT_GEN_DUR_G = $37
  OFFSET_X_REG_L_M = $05
  OFFSET_X_REG_H_M = $06
  OFFSET_Y_REG_L_M = $07
  OFFSET_Y_REG_H_M = $08
  OFFSET_Z_REG_L_M = $09
  OFFSET_Z_REG_H_M = $0A
  WHO_AM_I_M = $0F
  CTRL_REG1_M = $20
  CTRL_REG2_M = $21
  CTRL_REG3_M = $22
  CTRL_REG4_M = $23
  CTRL_REG5_M = $24
  STATUS_REG_M = $27
  OUT_X_L_M = $28
  OUT_X_H_M = $29
  OUT_Y_L_M = $2A
  OUT_Y_H_M = $2B
  OUT_Z_L_M = $2C
  OUT_Z_H_M = $2D
  INT_CFG_M = $30
  INT_SRC_M = $30
  INT_THS_L_M = $32
  INT_THS_H_M = $33
  WHO_AM_I_AG_RSP = $68
  WHO_AM_I_M_RSP = $3D
  FIFO_OFF = 0
  FIFO_THS = 1
  FIFO_CONT_TRIGGER = 3
  FIFO_OFF_TRIGGER = 4
  FIFO_CONT = 5
  X_AXIS = 0
  Y_AXIS = 1
  Z_AXIS = 2
  ALL_AXIS = 3
  CELSIUS = 0
  FAHRENHEIT = 1
  KELVIN = 2
'"simpletools.h"
  MSBFIRST = 1
  MSBPRE = 0
  LSBFIRST = 0
  LSBPRE = 1
  MSBPOST = 2
  LSBPOST = 3

  SCL_PIN = 5
  SDIO_PIN = 6
  CS_AG_PIN = 7
  CS_M_PIN = 8
  INT_AG_PIN = 9
  INT_M_PIN = 10
  VCC_PIN = 5
  GND_PIN = 4
  RED_LED_PIN = 3
  YLW_LED_PIN = 0
  GRN_LED_PIN = 2
  BUTTON_PIN = 0

OBJ
  time  : "time"
  ser   : "com.serial.terminal"
  spi   : "SPI_Spin"

VAR
  long __gx, __gy, __gz ' x, y, and z axis readings of the gyroscope
  long __ax, __ay, __az ' x, y, and z axis readings of the accelerometer
  long __mx, __my, __mz
  long tmp
  long timeout_monitor

  long __pinAG
  long __gRes
  long __gBias[3]
  long __gBiasRaw[3]
  byte __autoCalc

  byte __settings_accel_scale
  long __aRes
  long __aBias[3]
  long __aBiasRaw[3]

  long __pinM
  long __mRes

  long __pinSDIO, __pinSCL

  long __settings_gyro_scale
  
PUB main | test_result, whoAmI, axis_result, xgt, mt
  ser.Start (115_200)
  '#ifdef TEST_HARNESS
  repeat while (1)
    'set the test_result variable to 0.
    'bits: [0][magInt][accelInt][magOut][accelOut][gyroOut][whoAmI][shorts], test_result
    test_result := %00000000
    'set all of the IMU pins to High-Z
'    dira[VCC_PIN] := 0
'    dira[GND_PIN] := 0
    dira[SCL_PIN] := 0
    dira[SDIO_PIN] := 0
    dira[CS_AG_PIN] := 0
    dira[CS_M_PIN] := 0
    dira[INT_AG_PIN] := 0
    dira[INT_M_PIN] := 0
 {   'set the button to be an input
    dira[BUTTON_PIN] := 0
    'wait for a button press, then wait to debounce
    repeat while (ina[BUTTON_PIN])
    time.MSleep (100)
}
    repeat while not ser.CharIn
    ser.str(string("Testing.",13))
    low(RED_LED_PIN)
    high(YLW_LED_PIN)
    low(GRN_LED_PIN)
    'TODO test for shorts between pins?
    '---------------------------------------
    test_result |= %00000001
    '---------------------------------------
    'power the module
'    high(VCC_PIN)
'    low(GND_PIN)
    'initialize the IMU, get the whoAmI response, whoAmI
    dira[CS_AG_PIN & CS_M_PIN]:=1
    outa[CS_AG_PIN & CS_M_PIN]:=1
    dira[SCL_PIN]:=1
    outa[SCL_PIN]:=0
    time.MSleep (1)
    imu_SPIwriteByte(CS_AG_PIN, CTRL_REG8, %00001100)
    imu_SPIwriteByte(CS_M_PIN, CTRL_REG3_M, %10000100)

    imu_SPIreadBytes(CS_M_PIN, WHO_AM_I_M, mt, 1) ' Read the gyro WHO_AM_I
    imu_SPIreadBytes(CS_AG_PIN, WHO_AM_I_XG, xgt, 1) ' Read the accel/mag WHO_AM_I, whoAmICombined

    {
    high(__pinAG)
    high(__pinM)
    low(__pinSCL) ' Pin output state to low
    time.msleep(1)
  ' Set both the Accel/Gyro and Mag to 3-wire SPI mode
    imu_SPIwriteByte(__pinAG, CTRL_REG8, %00001100)
    imu_SPIwriteByte(__pinM, CTRL_REG3_M, %10000100)
  ' To verify communication, we can read from the WHO_AM_I register of
  ' each device. Store those in a variable so we can return them., xgTest, mTest
    imu_SPIreadBytes(__pinM, WHO_AM_I_M, mt, 1) ' Read the gyro WHO_AM_I
    imu_SPIreadBytes(__pinAG, WHO_AM_I_XG, xgt, 1) ' Read the accel/mag WHO_AM_I, whoAmICombined
}
    ser.Hex (mt, 2)
    ser.NewLine
    ser.Hex (xgt, 2)
    led
    
    '
    whoAmI := imu_init(SCL_PIN, SDIO_PIN, CS_AG_PIN, CS_M_PIN)
    ser.Hex (whoAmI, 4)
    ser.str(string("."))
    if (whoAmI == $683D)
      test_result |= %00000010
    '3-axis tests
    'bits: [z-axis][y-axis][x-axis], axis_result
    axis_result := %000
    if (test_result == %00000011)
      'test the gyro  
      'mark the system clock
      timeout_monitor := CNT
      'read the gyro
      imu_setGyroScale(245) 'most sensitive setting
      time.msleep(50)
      imu_readGyro(@__gx, @__gy, @__gz)
      ser.str(string("."))
      repeat while (timeout_monitor <(CNT + CLKFREQ / 250))
        'read the gyro
        imu_readGyro(@__ax, @__ay, @__az)
        'test for different results - if the sensor is working, there should be slight variations between readings
        if (__ax <> __gx)
          axis_result |= %001
        if (__ay <> __gy)
          axis_result |= %010
        if (__az <> __gz)
          axis_result |= %100
        'if all outputs pass, pass the gyro
        if (axis_result == %111)
          test_result |= %00000100
          quit
    if (test_result == %00000111)
      'test the accel 
      axis_result := %000
      'read the accel
      imu_setAccelScale(2) 'most sensitive setting
      time.msleep(50)
      imu_readAccel(@__gx, @__gy, @__gz)
      ser.str(string("."))
      'mark the system clock
      timeout_monitor := CNT + CLKFREQ
      'keep checking until timeout or true
      repeat while (timeout_monitor > CNT)
        'read the accel again
        imu_readAccel(@__ax, @__ay, @__az)
        'test for different results - if the sensor is working, there should be slight variations between readings
        if (__ax <> __gx)
          axis_result |= %001
        if (__ay <> __gy)
          axis_result |= %010
        if (__az <> __gz)
          axis_result |= %100
        'if all outputs pass, pass the accel
        if (axis_result == %111)
          test_result |= %00001000
          quit
    if (test_result == %00001111)
      'test the mag 
      axis_result := %000
      'read the mag
      imu_setMagScale(4) 'most sensitive setting
      time.msleep(50)
      imu_readMag(@__gx, @__gy, @__gz)
      ser.str(string("."))
      'mark the system clock
      timeout_monitor := CNT + CLKFREQ
      'keep checking until timeout or true
      repeat while (timeout_monitor > CNT)
        'read the mag again
        imu_readMag(@__ax, @__ay, @__az)
        'test for different results - if the sensor is working, there should be slight variations between readings
        if (__ax <> __gx)
          axis_result |= %001
        if (__ay <> __gy)
          axis_result |= %010
        if (__az <> __gz)
          axis_result |= %100
        'if all outputs pass, pass the mag
        if (axis_result == %111)
          test_result |= %00010000
          quit
    if (test_result == %00011111)
      'test the AG interrupt pin
      axis_result := %000
      'clear accelerometer interrupts
      imu_clearAccelInterrupt
      time.msleep(50)
      ser.str(string("."))
      if (not ina[INT_AG_PIN])'input(INT_AG_PIN))
        axis_result |= %001
      'set the accelerometer to interrupt if all axes less than 1.2g 
      imu_setAccelInterrupt(ALL_AXIS, 1.2, 20, 0, 0)
      timeout_monitor := CNT + CLKFREQ
      'keep checking until timeout or true
      repeat while (timeout_monitor > CNT)
        if (ina[INT_AG_PIN])'input(INT_AG_PIN))
          axis_result |= %010
        'if all outputs pass, pass the accel
        if (axis_result == %011)
          test_result |= %00100000
          quit
    if (test_result == %00111111)
      'clear magnetometer interrupts
      imu_clearMagInterrupt
      'test the M interrupt pin
      axis_result := %000
      ser.str(string("."))
      'clear magnetometer interrupts
      imu_clearMagInterrupt
      time.msleep(50)
      if (not ina[INT_M_PIN])'input(INT_M_PIN))
        axis_result |= %001
      'set the magnetometer to interrupt if y-axis (gravity) less than 1.2g 
      imu_setMagInterrupt(ALL_AXIS, 0.01, 1)
      'mark the system clock
      timeout_monitor := CNT + CLKFREQ
      'keep checking until timeout or true
      repeat while (timeout_monitor > CNT)
        if (ina[INT_M_PIN])'input(INT_M_PIN))
          axis_result |= %010
        'if all outputs pass, pass the accel
        if (axis_result == %011)
          test_result |= %01000000
          quit
      'clear magnetometer interrupts
      imu_clearMagInterrupt
    'report the result of the test
    low(YLW_LED_PIN)
    if (test_result == %01111111)
      high(GRN_LED_PIN)
      ser.str(string("Passed\r"))
    else
      high(RED_LED_PIN)
      ser.str(string("Failed Reason = "))
      ser.Dec (test_result)
      ser.NewLine
  
PUB imu_init(pinSCL, pinSDIO, pinAG, pinM) | xgTest, mTest, whoAmICombined

  high(__pinAG)
  high(__pinM)
  low(__pinSCL) ' Pin output state to low
  time.msleep(1)
  ' Set both the Accel/Gyro and Mag to 3-wire SPI mode
  imu_SPIwriteByte(__pinAG, CTRL_REG8, %00001100)
  imu_SPIwriteByte(__pinM, CTRL_REG3_M, %10000100)
  ' To verify communication, we can read from the WHO_AM_I register of
  ' each device. Store those in a variable so we can return them., xgTest, mTest
  imu_SPIreadBytes(__pinM, WHO_AM_I_M, @byte[@mTest], 1) ' Read the gyro WHO_AM_I
  imu_SPIreadBytes(__pinAG, WHO_AM_I_XG, @byte[@xgTest], 1) ' Read the accel/mag WHO_AM_I, whoAmICombined
  whoAmICombined := (byte[@xgTest] << 8) | byte[@mTest]
  if (whoAmICombined <>((WHO_AM_I_AG_RSP << 8) | WHO_AM_I_M_RSP))
    return 0
  'Init Gyro
  imu_SPIwriteByte(__pinAG, CTRL_REG1_G, $C0)
  imu_SPIwriteByte(__pinAG, CTRL_REG2_G, $00)
  imu_SPIwriteByte(__pinAG, CTRL_REG3_G, $00)
  imu_SPIwriteByte(__pinAG, CTRL_REG4, $38)
  imu_SPIwriteByte(__pinAG, ORIENT_CFG_G, $00)
  'Init Accel
  imu_SPIwriteByte(__pinAG, CTRL_REG5_XL, $38)
  imu_SPIwriteByte(__pinAG, CTRL_REG6_XL, $C0)
  imu_SPIwriteByte(__pinAG, CTRL_REG7_XL, $00)
  'Init Mag
  imu_SPIwriteByte(__pinM, CTRL_REG2_M, $00)
  imu_SPIwriteByte(__pinM, CTRL_REG4_M, $0C)
  imu_SPIwriteByte(__pinM, CTRL_REG5_M, $00)
  'Set Scales
  imu_setGyroScale(500)
  imu_setAccelScale(8)
  imu_setMagScale(12)
  ' Once everything is initialized, return the WHO_AM_I registers we read:
  return whoAmICombined

PUB imu_setGyroScale(gScl) | ctrl1RegValue
  if ((gScl <> 245) and (gScl <> 500) and (gScl <> 2000))
    gScl := 245
  __settings_gyro_scale := gScl
  __gRes := 32768.0 / (gScl)
  ' Read current value of CTRL_REG1_G:, ctrl1RegValue
  imu_SPIreadBytes(__pinAG, CTRL_REG1_G, @byte[@ctrl1RegValue], 1)
  ' Mask out scale bits (3 & 4):
  byte[@ctrl1RegValue] &= $E7
  case(gScl)
    500 :
      byte[@ctrl1RegValue] |= ($1 << 3)
      '500
    2000 :
      byte[@ctrl1RegValue] |= ($3 << 3)
    OTHER :
  imu_SPIwriteByte(__pinAG, CTRL_REG1_G, byte[@ctrl1RegValue])


PUB imu_readGyro(gx, gy, gz) | temp[2], tempX, tempY, tempZ ' We'll read six bytes from the gyro into temp, tempX, tempY, tempZ
  imu_SPIreadBytes(__pinAG, OUT_X_L_G, @temp, 6) ' Read 6 bytes, beginning at OUT_X_L_G
  word[@tempX] := (byte[@temp][1] << 8) | byte[@temp][0] ' Store x-axis values into gx
  word[@tempY] := (byte[@temp][3] << 8) | byte[@temp][2] ' Store y-axis values into gy
  word[@tempZ] := (byte[@temp][5] << 8) | byte[@temp][4] ' Store z-axis values into gz
  long[gx] := ~~word[@tempX]
  long[gy] := ~~word[@tempY]
  long[gz] := ~~word[@tempZ]
  if (__autoCalc)
    long[gx] -= __gBiasRaw[X_AXIS]
    long[gy] -= __gBiasRaw[Y_AXIS]
    long[gz] -= __gBiasRaw[Z_AXIS]

PUB imu_readGyroCalculated(gx, gy, gz) | tempX, tempY, tempZ
  ' Return the gyro raw reading times our pre-calculated DPS / (ADC tick):, tempX, tempY, tempZ
  imu_readGyro(@tempX, @tempY, @tempZ)
  long[gx] := (tempX) / __gRes
  long[gy] := (tempY) / __gRes
  long[gz] := (tempZ) / __gRes


PUB imu_setAccelScale(aScl) | tempRegValue
  if ((byte[@aScl] <> 2) and (byte[@aScl] <> 4) and (byte[@aScl] <> 8) and (byte[@aScl] <> 16))
    byte[@aScl] := 2
  __aRes := 32768.0 / (byte[@aScl])
  __settings_accel_scale := byte[@aScl]
  ' We need to preserve the other bytes in CTRL_REG6_XL. So, first read it:, tempRegValue
  imu_SPIreadBytes(__pinAG, CTRL_REG6_XL, @byte[@tempRegValue], 1)
  ' Mask out accel scale bits:
  byte[@tempRegValue] &= $E7
  case(byte[@aScl])
    4 :
      byte[@tempRegValue] |= ($2 << 3)
    8 :
      byte[@tempRegValue] |= ($3 << 3)
    16 :
      byte[@tempRegValue] |= ($1 << 3)
    OTHER :
  imu_SPIwriteByte(__pinAG, CTRL_REG6_XL, byte[@tempRegValue])

PUB imu_readAccel(ax, ay, az) | temp[2], tempX, tempY, tempZ ' We'll read six bytes from the accelerometer into temp  , tempX, tempY, tempZ
  imu_SPIreadBytes(__pinAG, OUT_X_L_XL, @temp, 6) ' Read 6 bytes, beginning at OUT_X_L_XL
  word[@tempX] := (byte[@temp][1] << 8) | byte[@temp][0] ' Store x-axis values into ax
  word[@tempY] := (byte[@temp][3] << 8) | byte[@temp][2] ' Store y-axis values into ay
  word[@tempZ] := (byte[@temp][5] << 8) | byte[@temp][4] ' Store z-axis values into az
  long[ax] := ~~word[@tempX]
  long[ay] := ~~word[@tempY]
  long[az] := ~~word[@tempZ]
  if (__autoCalc)
    long[ax] -= __aBiasRaw[X_AXIS]
    long[ay] -= __aBiasRaw[Y_AXIS]
    long[az] -= __aBiasRaw[Z_AXIS]

PUB imu_readAccelCalculated(ax, ay, az) | tempX, tempY, tempZ
  ' Return the accel raw reading times our pre-calculated g's / (ADC tick):, tempX, tempY, tempZ
  imu_readAccel(@tempX, @tempY, @tempZ)
  long[ax] := (tempX) / __aRes
  long[ay] := (tempY) / __aRes
  long[az] := (tempZ) / __aRes


DAT
  __settings_mag_scale byte 16

PUB imu_setMagScale(mScl) | temp
  if ((byte[@mScl] <> 4) and (byte[@mScl] <> 8) and (byte[@mScl] <> 12) and (byte[@mScl] <> 16))
    byte[@mScl] := 4
  ' We need to preserve the other bytes in CTRL_REG6_XM. So, first read it:, temp
  imu_SPIreadBytes(__pinM, CTRL_REG2_M, @byte[@temp], 1)
  ' Then mask out the mag scale bits:
  byte[@temp] &= $FF ^($3 << 5)
  case(byte[@mScl])
    8 :
      byte[@temp] |= ($1 << 5)
      __settings_mag_scale := 8
      __mRes := 3448.28
    12 :
      byte[@temp] |= ($2 << 5)
      __settings_mag_scale := 12
      __mRes := 2298.85
    16 :
      byte[@temp] |= ($3 << 5)
      __settings_mag_scale := 16
      __mRes := 1724.14
    OTHER :
      __settings_mag_scale := 4
      __mRes := 6896.55
  imu_SPIwriteByte(__pinM, CTRL_REG2_M, byte[@temp])

PUB imu_readMag(mx, my, mz) | temp[2], tempX, tempY, tempZ ' We'll read six bytes from the mag into temp  , tempX, tempY, tempZ
  imu_SPIreadBytes(__pinM, OUT_X_L_M, @temp, 6) ' Read 6 bytes, beginning at OUT_X_L_M
  word[@tempX] := (byte[@temp][1] << 8) | byte[@temp][0] ' Store x-axis values into gx
  word[@tempY] := (byte[@temp][3] << 8) | byte[@temp][2] ' Store y-axis values into gy
  word[@tempZ] := (byte[@temp][5] << 8) | byte[@temp][4] ' Store z-axis values into gz
  long[mx] := ~~word[@tempX]
  long[my] := ~~word[@tempY]
  long[mz] := ~~word[@tempZ]

PUB imu_readMagCalculated(mx, my, mz) | tempX, tempY, tempZ
  ' Return the mag raw reading times our pre-calculated Gs / (ADC tick):, tempX, tempY, tempZ
  imu_readMag(@tempX, @tempY, @tempZ)
  long[mx] := (tempX) / __mRes
  long[my] := (tempY) / __mRes
  long[mz] := (tempZ) / __mRes

PUB imu_clearAccelInterrupt | tempRegValue
  imu_SPIwriteByte(__pinAG, INT_GEN_THS_X_XL, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_THS_Y_XL, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_THS_Z_XL, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_CFG_XL, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_DUR_XL, $00)
  imu_SPIreadBytes(__pinAG, INT1_CTRL, @byte[@tempRegValue], 1)
  byte[@tempRegValue] &= $BF
  imu_SPIwriteByte(__pinAG, INT1_CTRL, byte[@tempRegValue])

PUB imu_clearGyroInterrupt | tempRegValue
  imu_SPIwriteByte(__pinAG, INT_GEN_THS_XH_G, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_THS_XL_G, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_THS_YH_G, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_THS_YL_G, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_THS_ZH_G, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_THS_ZL_G, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_CFG_G, $00)
  imu_SPIwriteByte(__pinAG, INT_GEN_DUR_G, $00)
  imu_SPIreadBytes(__pinAG, INT1_CTRL, @byte[@tempRegValue], 1)
  byte[@tempRegValue] &= $7F
  imu_SPIwriteByte(__pinAG, INT1_CTRL, byte[@tempRegValue])

PUB imu_clearMagInterrupt | tempRegValue
  imu_SPIwriteByte(__pinM, INT_THS_L_M, $00)
  imu_SPIwriteByte(__pinM, INT_THS_H_M, $00)
  imu_SPIwriteByte(__pinM, INT_SRC_M, $00)
  imu_SPIwriteByte(__pinM, INT_CFG_M, $00)

PUB imu_setAccelInterrupt(axis, threshold, duration, overUnder, andOr) | tempRegValue, accelThs, tempThs
  byte[@overUnder] &= $01
  byte[@andOr] &= $01
  byte[@tempRegValue] := 0
  imu_SPIreadBytes(__pinAG, CTRL_REG4, @byte[@tempRegValue], 1) ' Make sure interrupt is NOT latched
  byte[@tempRegValue] &= $FD
  imu_SPIwriteByte(__pinAG, CTRL_REG4, byte[@tempRegValue])
  imu_SPIreadBytes(__pinAG, INT_GEN_CFG_XL, @byte[@tempRegValue], 1)
  if (byte[@andOr])
    byte[@tempRegValue] |= $80
  else
    byte[@tempRegValue] &= $7F
  if (threshold < 0)
    threshold := -1 * threshold
  byte[@accelThs] := 0
  tempThs := 0
  tempThs := ((__aRes * threshold)) >> 7
  byte[@accelThs] := tempThs & $FF
  case(byte[@axis])
    X_AXIS :
      byte[@tempRegValue] |= (1 <<(0 + byte[@overUnder]))
      imu_SPIwriteByte(__pinAG, INT_GEN_THS_X_XL, byte[@accelThs])
    Y_AXIS :
      byte[@tempRegValue] |= (1 <<(2 + byte[@overUnder]))
      imu_SPIwriteByte(__pinAG, INT_GEN_THS_Y_XL, byte[@accelThs])
    Z_AXIS :
      byte[@tempRegValue] |= (1 <<(4 + byte[@overUnder]))
      imu_SPIwriteByte(__pinAG, INT_GEN_THS_Z_XL, byte[@accelThs])
    OTHER :
      imu_SPIwriteByte(__pinAG, INT_GEN_THS_X_XL, byte[@accelThs])
      imu_SPIwriteByte(__pinAG, INT_GEN_THS_Y_XL, byte[@accelThs])
      imu_SPIwriteByte(__pinAG, INT_GEN_THS_Z_XL, byte[@accelThs])
      byte[@tempRegValue] |= (%00010101 << byte[@overUnder])
  imu_SPIwriteByte(__pinAG, INT_GEN_CFG_XL, byte[@tempRegValue])
  if (byte[@duration] > 0)
    byte[@duration] := $80 | (byte[@duration] & $7F)
  else
    byte[@duration] := $00
  imu_SPIwriteByte(__pinAG, INT_GEN_DUR_XL, byte[@duration])
  imu_SPIreadBytes(__pinAG, INT1_CTRL, @byte[@tempRegValue], 1)
  byte[@tempRegValue] |= $40
  imu_SPIwriteByte(__pinAG, INT1_CTRL, byte[@tempRegValue])

PUB imu_setMagInterrupt(axis, threshold, lowHigh) | tempCfgValue, tempSrcValue, magThs, magThsL, magThsH
  byte[@lowHigh] &= $01
  byte[@tempCfgValue] := $00
  byte[@tempCfgValue] |= (byte[@lowHigh] << 2)
  byte[@tempCfgValue] |= $03
  byte[@tempSrcValue] := $00
  magThs := 0
  byte[@magThsL] := 0
  byte[@magThsH] := 0
  magThs := (__mRes * threshold)
  if (magThs < 0)
    magThs := -1 * magThs
  if (magThs > 32767)
    magThs := 32767
  byte[@magThsL] := magThs & $FF
  byte[@magThsH] := (magThs >> 8) & $7F
  imu_SPIwriteByte(__pinM, INT_THS_L_M, byte[@magThsL])
  imu_SPIwriteByte(__pinM, INT_THS_H_M, byte[@magThsH])
  case(byte[@axis])
    X_AXIS :
      byte[@tempCfgValue] |= (1 << 7)
    Y_AXIS :
      byte[@tempCfgValue] |= (1 << 6)
    Z_AXIS :
      byte[@tempCfgValue] |= (1 << 5)
    OTHER :
      byte[@tempCfgValue] |= (%11100000)
  imu_SPIwriteByte(__pinM, INT_CFG_M, byte[@tempCfgValue])

PUB imu_SPIwriteByte(csPin, subAddress, data)
  low(byte[@csPin])
  shift_out(__pinSDIO, __pinSCL, MSBFIRST, 8, byte[@subAddress] & $3F)
  shift_out(__pinSDIO, __pinSCL, MSBFIRST, 8, byte[@data])
  high(byte[@csPin])

PUB imu_SPIreadBytes(csPin, subAddress, dest, count) | rAddress, i
  ' To indicate a read, set bit 0 (msb) of first byte to 1, rAddress
  byte[@rAddress] := $80 | (byte[@subAddress] & $3F)
  ' Mag SPI port is different. If we're reading multiple bytes, 
  ' set bit 1 to 1. The remaining six bytes are the address to be read
  if ((byte[@csPin] == __pinM) and byte[@count] > 1)
    byte[@rAddress] |= $40
  low(byte[@csPin])
  shift_out(__pinSDIO, __pinSCL, MSBFIRST, 8, byte[@rAddress])
  i := 0
  repeat while (i < byte[@count])
    byte[dest][i] := shift_in(__pinSDIO, __pinSCL, MSBPRE, 8)
    i++
  high(byte[@csPin])


PUB shift_out(pinDat, pinClk, mode, bits, value) | vi, vf, inc, i
  set_direction(pinDat, 1)
  if (mode == LSBFIRST)
    vi := 0
    vf := bits
    inc := 1
  else
    vi := bits - 1
    vf := -1
    inc := -1
  low(pinClk)
  i := vi
  repeat while (i <> vf)
    set_output(pinDat,(value >> i) & 1)
    toggle(pinClk)
    toggle(pinClk)
    i += inc

PUB shift_in(pinDat, pinClk, mode, bits) | vi, vf, inc, value, preflag, i
  value := 0
  preflag := 0
  if ((mode == MSBPRE) or (mode == LSBPRE))
    preflag := 1
  case(mode)
    MSBPRE :
      vi := bits - 1
      vf := -1
      inc := -1
      'value |= (input(pinDat) << bits);
    LSBPRE :
      vi := 0
      vf := bits
      inc := 1
      value |= ina[pinDat]
    MSBPOST :
      vi := bits - 1
      vf := -1
      inc := -1
    OTHER : ' case LSBPOST:
      vi := 0
      vf := bits
      inc := 1
  low(pinClk)
  i := vi
  repeat while (i <> vf)
    if (preflag)
      value |= (ina[pinDat] << i)
    toggle(pinClk)
    toggle(pinClk)
    'if(!i)
    '{
    '  if(preflag) break;
    '}
    if (not preflag)
      value |= (ina[pinDat] << i)
    i += inc
  return value

PRI set_direction(pin, dir)

  dira[pin]:=dir

PRI toggle(pin)

  !outa[pin]
  
PRI set_output(pin, state)

  outa[pin] := 0 #> state <# 1
  
PRI high(pin)

'  set_output(pin, 1)
  dira[pin]:=1
  outa[pin]:=1
  
PRI low(pin)

'  set_output(pin, 1)
  dira[pin]:=1
  outa[pin]:=0

PUB led
  dira[1]:=1
  repeat
    !outa[1]
    waitcnt(cnt+clkfreq/10)
    

  
{*
 * TERMS OF USE: MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 }

